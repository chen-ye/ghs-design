<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8 />
        <title>GHS Flight Paths Demo</title>
        <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
        <script src='https://api.tiles.mapbox.com/mapbox.js/v2.1.4/mapbox.js'></script>
        <link href='https://api.tiles.mapbox.com/mapbox.js/v2.1.4/mapbox.css' rel='stylesheet' />
        <style>
            body { margin:0; padding:0; }
            #map { position:absolute; top:0; bottom:0; width:100%; }
        </style>
    </head>
    <body>
        <!-- We use arc.js to make our paths curved. -->
        <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/arc.js/v0.1.0/arc.js'></script>
        <!-- This is our data file - it's an array of [[lat,lng],[lat,lng]] pairs
that define starting and ending locations of flight paths 
            At some point, this is gonna be replaced by a dynamic api -->
        <script src='js/flights.js'></script>

        <style>
            /*
            * The path-start class is added to each line
            * to manage its animation - this interpolates
            * between the starting and ending values for the
            * stroke-dashoffset css property
            */
            .path-start {
                -webkit-transition:stroke-dashoffset 10s ease-in;
                -moz-transition:stroke-dashoffset 10s ease-in;
                -o-transition:stroke-dashoffset 10s ease-in;
                transition:stroke-dashoffset 10s ease-in;
                -webkit-animation: flightpath 80s linear normal infinite;
/*                -webkit-animation-delay: 10s;*/
                animation: flightpath 80s linear normal infinite;
/*                animation-delay: 10s;*/
            }
            
            .path-start.secondary {
                opacity: .1;
                animation: none;
/*                animation: flightpath 160s linear normal infinite;*/
            }
            
            @-webkit-keyframes flightpath {
                from {
                    stroke-dashoffset: 1000;
                }
                to {
                    stroke-dashoffset: -1000;
                }
            }
            
            @keyframes flightpath {
                from {
                    stroke-dashoffset: 4000;
                }
                to {
                    stroke-dashoffset: -4000;
                }
            }
        </style>

        <div id='map' class='dark'></div>

        <script>
            L.mapbox.accessToken = 'pk.eyJ1IjoiYmxhc3Rlcm50IiwiYSI6ImlwalZmdUkifQ.TJCtxxyNmRhvH-17afmGng';
            // This is an advanced example that is compatible with
            // modern browsers and IE9+ - the trick it uses is animation
            // of SVG properties, which makes it relatively efficient for
            // the effect produced. That said, the same trick means that the
            // animation is non-geographical - lines interpolate in the same
            // amount of time regardless of trip length.

            
            var map, geocoder = L.mapbox.geocoder('mapbox.places');
            geocoder.query('Seoul', showMap);
            
            function seoulFilter (value, i, ar) {
                if (value[0][0]==37.469075 || value[1][0]==37.469075) {
                    return true;
                } else return false;
            }
            
            function showMap(err, data) {
                map = L.mapbox.map('map', 'blasternt.cddf600d', {
                    attributionControl: false,
                    infoControl: true,
                    zoomControl: false,
                }).setView([data.latlng[0], data.latlng[1]], 4);
                map.infoControl
                .addInfo('<a href="http://openflights.org/data.html">Flight data from Open Flights, under the ODbL license</a>');
                // Disable drag and zoom handlers.
                // Making this effect work with zooming and panning
                // would require a different technique with different
                // tradeoffs.
                map.dragging.disable();
                map.touchZoom.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
                if (map.tap) map.tap.disable();

                // Transform the short [lat,lng] format in our
                // data into the {x, y} expected by arc.js.
                function obj(ll) { return { y: ll[0], x: ll[1] }; }
                
                
                
//                var filteredPairs = pairs.filter(seoulFilter),
//                    otherPairs = pairs.filter(function(val, i , arr) {return !seoulFilter(val, i , arr)});
                

                for (var i = 0; i < pairs.length; i++) {
                    // Transform each pair of coordinates into a pretty
                    // great circle using the Arc.js plugin, as included above.
                    var generator = new arc.GreatCircle(
                        obj(pairs[i][0]),
                        obj(pairs[i][1]));
                    var line = generator.Arc(100, { offset: 10 });
                    // Leaflet expects [lat,lng] arrays, but a lot of
                    // software does the opposite, including arc.js, so
                    // we flip here.
                    var newLine = L.polyline(line.geometries[0].coords.map(function(c) {
                        return c.reverse();
                    }), {
                        color: '#fff',
                        weight: 1,
                        opacity: 0.5
                    })
                    .addTo(map);
                    var totalLength = newLine._path.getTotalLength();
                    newLine._path.classList.add('path-start');
                    if (pairs[i][0][0] != 37.469075 && pairs[i][1][0] != 37.469075) {
                        newLine._path.classList.add('secondary');
                    }
                    // This pair of CSS properties hides the line initially
                    // See http://css-tricks.com/svg-line-animation-works/
                    // for details on this trick.
                    newLine._path.style.strokeDashoffset = totalLength;
                    newLine._path.style.strokeDasharray = 1.5 * totalLength;
                    // Offset the timeout here: setTimeout makes a function
                    // run after a certain number of milliseconds - in this
                    // case we want each flight path to be staggered a bit.
                    setTimeout((function(path) {
                        return function() {
                            // setting the strokeDashoffset to 0 triggers
                            // the animation.
                            path.style.strokeDashoffset = 0;
                        };
                    })(newLine._path), i * 100);
                }
            }
        </script>
    </body>
</html>